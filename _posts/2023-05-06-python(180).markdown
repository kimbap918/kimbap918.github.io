---
layout: post
title: 파이썬 숨바꼭질(BOJ 1697)
date: 2023-05-06 06:30:00 +0900
image: 백준.png
tags: 알고리즘 그래프_이론 그래프_탐색 너비_우선_탐색
categories: 문제풀이
---

<br>

## 문제

수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 1초 후에 2*X의 위치로 이동하게 된다.

수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오.

<br>

## 입력

첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다.

<br>

## 출력

수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.

<br>

## 예제 입력 1 

```
5 17
```

## 예제 출력 1 

```
4
```

<br>

## 힌트

수빈이가 5-10-9-18-17 순으로 가면 4초만에 동생을 찾을 수 있다.

<br>

## 📝 풀어보기 

문제의 N의 최대 범위가 10만이므로 100001까지 범위를 잡았다.

arr은 해당 위치에 도착했을 때 시간을 나타내는 리스트다.

수빈이가 있는 위치 N, 동생이 있는 위치 K를 입력받고 BFS를 실행한다.

``` python
MAX = 100001
arr = [0] * MAX
N, K = map(int, input().split())
print(BFS(N))
```

<br>

BFS를 정의한다.

deque를 만들어 시작점의 위치(v)를 저장해둔다.

위치값을 빼내서 x에 저장해두고 수빈이의 위치(x)가 동생의 위치(K)와 같아질때까지 반복을 하고, 같아지면 도착시간을 반환한다.

기존 위치에서 이동할 수 있는 위치는 x-1, x+1, x*2로 총 3가지이다. 

이 범위(nx)에 있고, 아직 방문을 하지 않았다면 이동한 위치에 이동한 시간을 표시하고 큐에 nx값을 추가한다. 

``` python
def BFS(v):
    Q = deque([v])
    while Q:
        x = Q.popleft()
        if x == K:
            return arr[x]
        # X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 
        # 순간이동을 하는 경우에는 1초 후에 2*X의 위치로 이동하게 된다.
        # 기존 위치에서 이동하는 위치는 3가지
        for nx in (x-1, x+1, x*2):
            # x-1, x+1 x*2이 범위를 벗어나면 안된다.
            if 0 <= nx <= MAX and not arr[nx]:
                arr[nx] = arr[x]+1
                Q.append(nx)
```

<br>

#### 전체코드

``` python
import sys
from collections import deque
input = sys.stdin.readline

def BFS(v):
    Q = deque([v])
    while Q:
        x = Q.popleft()
        if x == K:
            return arr[x]
        # X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 
        # 순간이동을 하는 경우에는 1초 후에 2*X의 위치로 이동하게 된다.
        # 기존 위치에서 이동하는 위치는 3가지
        for nx in (x-1, x+1, x*2):
            # x-1, x+1 x*2이 범위를 벗어나면 안된다.
            if 0 <= nx <= MAX and not arr[nx]:
                arr[nx] = arr[x]+1
                Q.append(nx)

MAX = 100001
arr = [0] * MAX
N, K = map(int, input().split())
print(BFS(N))
```

