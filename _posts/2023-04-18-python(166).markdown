---
layout: post
title: 파이썬 파일 합치기(BOJ 11066)
date: 2023-04-18 16:30:00 +0900
image: 백준.png
tags: 알고리즘 다이나믹_프로그래밍
categories: 문제풀이
---

## 파이썬 파일 합치기(BOJ 11066)

<br>

## 문제

소설가인 김대전은 소설을 여러 장(chapter)으로 나누어 쓰는데, 각 장은 각각 다른 파일에 저장하곤 한다. 소설의 모든 장을 쓰고 나서는 각 장이 쓰여진 파일을 합쳐서 최종적으로 소설의 완성본이 들어있는 한 개의 파일을 만든다. 이 과정에서 두 개의 파일을 합쳐서 하나의 임시파일을 만들고, 이 임시파일이나 원래의 파일을 계속 두 개씩 합쳐서 소설의 여러 장들이 연속이 되도록 파일을 합쳐나가고, 최종적으로는 하나의 파일로 합친다. 두 개의 파일을 합칠 때 필요한 비용(시간 등)이 두 파일 크기의 합이라고 가정할 때, 최종적인 한 개의 파일을 완성하는데 필요한 비용의 총 합을 계산하시오.

예를 들어, C1, C2, C3, C4가 연속적인 네 개의 장을 수록하고 있는 파일이고, 파일 크기가 각각 40, 30, 30, 50 이라고 하자. 이 파일들을 합치는 과정에서, 먼저 C2와 C3를 합쳐서 임시파일 X1을 만든다. 이때 비용 60이 필요하다. 그 다음으로 C1과 X1을 합쳐 임시파일 X2를 만들면 비용 100이 필요하다. 최종적으로 X2와 C4를 합쳐 최종파일을 만들면 비용 150이 필요하다. 따라서, 최종의 한 파일을 만드는데 필요한 비용의 합은 60+100+150=310 이다. 다른 방법으로 파일을 합치면 비용을 줄일 수 있다. 먼저 C1과 C2를 합쳐 임시파일 Y1을 만들고, C3와 C4를 합쳐 임시파일 Y2를 만들고, 최종적으로 Y1과 Y2를 합쳐 최종파일을 만들 수 있다. 이때 필요한 총 비용은 70+80+150=300 이다.

소설의 각 장들이 수록되어 있는 파일의 크기가 주어졌을 때, 이 파일들을 하나의 파일로 합칠 때 필요한 최소비용을 계산하는 프로그램을 작성하시오.

<br>

## 입력

프로그램은 표준 입력에서 입력 데이터를 받는다. 프로그램의 입력은 T개의 테스트 데이터로 이루어져 있는데, T는 입력의 맨 첫 줄에 주어진다.각 테스트 데이터는 두 개의 행으로 주어지는데, 첫 행에는 소설을 구성하는 장의 수를 나타내는 양의 정수 K (3 ≤ K ≤ 500)가 주어진다. 두 번째 행에는 1장부터 K장까지 수록한 파일의 크기를 나타내는 양의 정수 K개가 주어진다. 파일의 크기는 10,000을 초과하지 않는다.

<br>

## 출력

프로그램은 표준 출력에 출력한다. 각 테스트 데이터마다 정확히 한 행에 출력하는데, 모든 장을 합치는데 필요한 최소비용을 출력한다.

<br>

## 예제 입력 1

```
2
4
40 30 30 50
15
1 21 3 4 5 35 5 4 3 5 98 21 14 17 32
```

## 예제 출력 1

```
300
864
```

<br>

## 📝 풀어보기

https://suri78.tistory.com/15 해당 블로그를 참고했다.

<br>

파일들의 최소값이 어떻게 구해지는지 알아보자.

files = [40, 30, 30] 이라고 가정했을 때, 계산되는 비용의 경우는 다음과 같다.

1. (file[0] + file[1]) + file[2]

2. file[0] + (file[1] + file[2])

1번의 경우엔 (40+30) = **70**, (**70**+30) = 100

2번의 경우엔 (30+30) = **60**, (**60**+40) = 100

똑같이 두번째의 합의 비용은 100이 나오지만 첫 번째 합의 비용이 다르다는걸 알 수 있다.

두 번째의 합의 비용이 100으로 같은 이유는 **마지막 합의 비용은 결국 0부터 2까지의 모든 수를 더한 값과 같기 때문**이다.

따라서, 최소값을 결정해주는 것은 마지막 합의 비용이 아니라 **이전의 비용**이다. 이 부분을 min(minimum)을 통해서 구한다.

minimum에는 `table[i][k] + table[k+1][j]` ((i~k까지 더한 비용의 최솟값) + (k+1~j까지 더한 비용의 최솟값)) 의 값들이 들어가게 된다. 이 최소비용을 `table[i][j]`에 합산해주면 전체의 최소비용을 구할 수 있다.

#### 전체코드

``` python
# 1. 파일을 합치는 횟수는 K-1로 모든 조건에서 동일하다
import sys
input = sys.stdin.readline

T = int(input())
for _ in range(T):
    K = int(input())
    files = list(map(int, input().split()))
    table = [[0] * K for _ in range(K)]

#   table[i][j] = table[i][j-1] + files[j] + min(minimum)
    for i in range(K-1):
        # 합의 비용을 계산한다. 
        # 40 30 30 50일때,
        table[i][i+1] = files[i] + files[i+1] # 40+30 = 70, 30+30 = 60, 30+50 = 80
        # print(table)
        # K개의 행까지
        for j in range(i+2, K): # 2, 3, 3
            # table[0][2] [0][3], [1][3] = table[0][1]+file[2], table[0][2] =[0][2]+[3], [1][2]+[3]
            # 첫번째 합의 비용(70)에서 남은 비용(30, 50)을 더해서 기록 
            table[i][j] = table[i][j-1] + files[j] # 70+30 = 100, 100+50 = 150, 60+50 = 110 
            # print("files : "+str(files[j]))
            # print("table[i][j-1] : "+str(table[i][j-1]))
            # print(table)
    for d in range(2, K): # 2, 3
        for i in range(K-d): # 4-2 = 2, 4-3, 1
            j = i+d
            # print(table)
            # print(i, j) # i=0, j=3
            # ((i~k까지 더한 비용의 최솟값) + (k+1~j까지 더한 비용의 최솟값))
            # 0 0 1 3 = 170, 0 1 2 3 = 150, 0 2 3 3 = 300
            # min = 150
            minimum = [table[i][k] + table[k+1][j] for k in range(i, j)] # 0 1 2
            # 150 + 150
            table[i][j] += min(minimum)
            # print(table)

    print(table[0][K-1])
```
