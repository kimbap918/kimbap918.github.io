---
layout: post
title: 파이썬 가장 긴 바이토닉 부분 수열(백준 BOJ 11054)
date: 2022-09-30 22:50:00 +0900
image: 백준.png
tags: 알고리즘
categories: 문제풀이
---

<br>

## 문제

수열 S가 어떤 수 Sk를 기준으로 S1 < S2 < ... Sk-1 < Sk > Sk+1 > ... SN-1 > SN을 만족한다면, 그 수열을 바이토닉 수열이라고 한다.

예를 들어, {10, 20, **30**, 25, 20}과 {10, 20, 30, **40**}, {**50**, 40, 25, 10} 은 바이토닉 수열이지만,  {1, 2, 3, 2, 1, 2, 3, 2, 1}과 {10, 20, 30, 40, 20, 30} 은 바이토닉 수열이 아니다.

수열 A가 주어졌을 때, 그 수열의 부분 수열 중 바이토닉 수열이면서 가장 긴 수열의 길이를 구하는 프로그램을 작성하시오.

<br>

## 입력

첫째 줄에 수열 A의 크기 N이 주어지고, 둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ N ≤ 1,000, 1 ≤ Ai ≤ 1,000)

<br>

## 출력

첫째 줄에 수열 A의 부분 수열 중에서 가장 긴 바이토닉 수열의 길이를 출력한다.

<br>

## 예제 입력 1

```
10
1 5 2 1 4 3 4 5 2 1
```

## 예제 출력 1

```
7
```

## 힌트

예제의 경우 {**1** 5 **2** 1 4 **3** **4** **5** **2** **1**}이 가장 긴 바이토닉 부분 수열이다.

<br>

## 📝 풀어보기

바이토닉 수열은 앞전의 가장 긴 증가하는 부분 수열(BOJ 11053)을 정방향으로 반복하고 저장, 역방향으로 반복하고 저장한것을 더하면 바이토닉 수열이 나온다.

``` python
n = int(input())
a = list(map(int, input().split()))
dpA = [0 for i in range(n)]
dpB = [0 for i in range(n)]
dpC = [0 for i in range(n)]
for i in range(n):
    for j in range(i):
        if a[i] > a[j] and dpA[i] < dpA[j]:
            dpA[i] = dpA[j]
    dpA[i] += 1
    
for i in range(n - 1, -1, -1):
    for j in range(n - 1, i, -1):
        if a[i] > a[j] and dpB[i] < dpB[j]:
            dpB[i] = dpB[j]
    dpB[i] += 1
    
for i in range(n):
    dpC[i] = dpA[i] + dpB[i] - 1
print(max(dpC))
```



