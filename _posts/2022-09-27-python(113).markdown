---
layout: post
title: 파이썬 쉬운 계단 수(백준 BOJ 10844)
date: 2022-09-27 23:40:00 +0900
image: 백준.png
tags: 알고리즘
categories: 문제풀이
---

<br>

## 문제

45656이란 수를 보자.

이 수는 인접한 모든 자리의 차이가 1이다. 이런 수를 계단 수라고 한다.

N이 주어질 때, 길이가 N인 계단 수가 총 몇 개 있는지 구해보자. 0으로 시작하는 수는 계단수가 아니다.

<br>

## 입력

첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 100보다 작거나 같은 자연수이다.

<br>

## 출력

첫째 줄에 정답을 1,000,000,000으로 나눈 나머지를 출력한다.

<br>

## 예제 입력 1 

```
1
```

## 예제 출력 1 

```
9
```

## 예제 입력 2 

```
2
```

## 예제 출력 2 

```
17
```

<br>

## 📝 풀어보기

1) 0 1 1 1 1 1 1 1 1 1 (자릿수가 1일때 모든 차이 1)
2) 1 1 2 2 2 2 2 2 2 1 (자릿수가 2일때 0 = 01(불가) 10, 1 = 21, 2 = 12, 32) 
3) 1 3 3 4 4 4 4 4 3 2 (자릿수가 3일때 0 = 010(불가), 210, 1 =  101, 121, 321 

<br>

규칙을 살펴보면 구하고자 하는 자리수의 값은 이전 자리수의 뒤와 앞이다.

예를들어 `arr[2][1] ` 의 값을 알고싶다면 `arr[1][0]` 과 `arr[1][2]` 의 값을 더하면 된다. 

0번째는 이전의 값이 없으므로, `arr[2][0]` 을 구한다면 `arr[1][1]` 의 값만 구하면 될것이다. 

9번째는 다음의 값이 없으므로 , `arr[2][9]` 를 구한다면 `arr[1]][8]` 의 값만 구하면 될것이다.

이 규칙에 대한 코드는 다음과 같다.

``` python
N = int(input())
MOD = 1000000000 # 정답에서 10억을 나눈 값 출력

# 0부터 9까지, N+1(숫자의 자리 수) 만큼 생성
dp = [[0] * 10 for i in range(N+1)]

# 1자리 수 일때 N = 1
# 1자리 수는 0을 제외한 1~9까지 모두 1의 차이를 가짐
for i in range(1, 10):
    dp[1][i] = 1

for i in range(2, N+1):
    for j in range(10):
        if j == 0: # 앞에 오는 숫자가 0이라면
            dp[i][j] = dp[i-1][1] # 처음 수의 앞에는 인덱스 1밖에 존재하지 않는다
        elif j == 9: # j가 마지막 수라면
            # 마지막 수의 뒤에는 인덱스 8밖에 존재하지 않는다.
            dp[i][j] = dp[i-1][8]
        else: # 1~8까지의 수 
            dp[i][j] = dp[i-1][j-1] + dp[i-1][j+1] # j의 앞 뒤수가 계단수가 될수있다.

print(sum(dp[N]) % MOD)
```

